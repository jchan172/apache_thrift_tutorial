// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "AddressBook.h"
#include <thrift/protocol/TCompactProtocol.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <iostream>
#include <fstream>

using namespace std;
using namespace apache::thrift;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using namespace apache::thrift::server;

using boost::shared_ptr;

using namespace addressbook;

class AddressBookHandler : virtual public AddressBookIf {
private:
	string serialize(ContactsList& obj, string filename) {
		// Create a memory buffer.
		shared_ptr<TMemoryBuffer> transportOut(new TMemoryBuffer());
		// Wrap the memory buffer in compact protocol.
		shared_ptr<TCompactProtocol> protocolOut(new TCompactProtocol(transportOut)); // Alternatively, use binary protocol: shared_ptr<TBinaryProtocol> protocolOut(new TBinaryProtocol(transportOut));
		// Get pointer to protocol and feed it to input object's .write() method. Object basically writes into buffer.
		obj.write(protocolOut.get());
		// Get the buffer's contents as a string.
		string serialized_string = transportOut->getBufferAsString();
		// Return that string.
		return serialized_string;
	}

	ContactsList deserialize(ContactsList& object, char* input, int input_length) {
		// Create a memory buffer from input (input_copy because TMemoryBuffer needs to be initialized with unsigned char*).
		shared_ptr<TMemoryBuffer> transportIn(new TMemoryBuffer((unsigned char*)input, input_length, TMemoryBuffer::OBSERVE));
		// Wrap memory buffer in compact protocol.
		shared_ptr<TCompactProtocol> protocolIn(new TCompactProtocol(transportIn)); // Alternatively, use binary protocol: shared_ptr<TBinaryProtocol> protocolIn(new TBinaryProtocol(transportIn));
		// Get pointer to protocol and feed it into object's .read() method. Object reads memory buffer and populates itself.
		object.read(protocolIn.get()); // can use .get() method because protocolIn is a boost shared_ptr
		// Return the populated object.
		return object;
	}

public:
	AddressBookHandler() {
		// Your initialization goes here
	}

	void listAll(std::string& _return, const std::string& filename) {
		// Your implementation goes here
		ContactsList contacts;
		ContactsList empty;
		cout << "List all.\n";
		// contacts = deserialize(empty, contacts_list);
	}

	void addContact(std::string& _return, const Person& person, const std::string& filename) {
		ContactsList contacts;

		// Create a reader to read file.
		ifstream reader(filename.c_str(), std::ifstream::binary);
		// Get length of file by setting reader position to end of file, saving position (which is length of file), then moving reader back to beginning position)
		reader.seekg (0, reader.end);
		int length = reader.tellg();
		reader.seekg (0, reader.beg);
		if (length > 0) {
			// Create empty string to save contents of file.
			char* contacts_binary = new char[length]();	
			cout << "here\n";
			// Read the file into empty contacts_binary string.
			reader.read(contacts_binary, length);
			// Close the reader and file.
			reader.close();

			// Create empty ContactsList Thrift object.
			ContactsList empty;
			// Load the contacts from address book file.
			contacts = deserialize(empty, contacts_binary, length);	
		} else {
			cout << filename + ": File not found. Creating new file." << endl;
		}

		// Append the new person to the loaded contacts.
		contacts.list_of_people.push_back(person);
		// Serialize the contacts into Thrift binary so that it's ready to be written out to disk.
		string serialized = serialize(contacts, filename);

		// Create a file writer for writing to disk.
		ofstream writer(filename.c_str(), std::ofstream::binary);
		// Write the serialized string to disk.
		writer.write(serialized.c_str(), serialized.size());
		// Close file writer.
		writer.close();
	}

};

int main(int argc, char **argv) {
	int port = 9090;
	shared_ptr<AddressBookHandler> handler(new AddressBookHandler());
	shared_ptr<TProcessor> processor(new AddressBookProcessor(handler));
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
	// printf("Starting server...\n");
	cout << "Starting server...\n";
	server.serve();
	cout << "Done.\n";
	return 0;
}

