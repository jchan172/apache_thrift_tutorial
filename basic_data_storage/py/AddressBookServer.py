#!/usr/bin/env python

import sys
sys.path.append('../gen-py')

from addressbook import AddressBook
from addressbook.ttypes import *

# Import the Thrift stack
from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.server import TServer


class AddressbookHandler:
  def __init__(self):
    self.log = {}

  # This function serializes a Thrift object into Thrift binary string
  # so that object can be written to filesystem.
  # Arguments:
  #   msg: Thrift object you want to serialize
  # Output:
  #   serialized_string: serialized string version of the input
  def serialize(self, msg):
    # Create a memory buffer.
    transportOut = TTransport.TMemoryBuffer()
    # Wrap the memory buffer in binary protocol.
    protocolOut = TBinaryProtocol.TBinaryProtocol(transportOut) # Alternatively, use binary protocol: protocolOut = TBinaryProtocol.TBinaryProtocol(transportOut)
    # Call the write method of the input (input Thrift object has .write 
    # method generated by Thrift compiler (see 'ttypes.py')), feeding it the 
    # protocol. Essentially, object writes itself into memory buffer.
    msg.write(protocolOut)
    # Get the memory buffer's contents as a string.
    serialized_string = transportOut.getvalue()
    # Return that string.
    return serialized_string

  # This function deserializes a Thrift binary file back into an object
  # Arguments:
  #   msg: empty version Thrift object you want to get back
  #   data: the string you want to deserialize
  # Output:
  #   msg: populated Thrift object
  def deserialize(self, msg, data):
    # Create a memory buffer from input.
    transport_in = TTransport.TMemoryBuffer(data)
    # Wrap memory buffer in binary protocol.
    protocol_in = TBinaryProtocol.TBinaryProtocol(transport_in) # Alternatively, use binary protocol: protocol_in = TBinaryProtocol.TBinaryProtocol(transport_in)
    # Call the read method of the Thrift object to populate it.
    msg.read(protocol_in)
    return msg

  def listAll(self, filename):
    contacts_list = "";
   # Read the existing address book.  
    try:
      # Open address book file for reading.
      f = open(filename, "rb")
      # Read the address book and save into variable.
      contacts_list = f.read()
      # Close the file.
      f.close()
    except IOError:
      print filename + ": File not found. Quit and run client again."

    contacts = ContactsList()
    contacts.list_of_people = []
    contacts = self.deserialize(ContactsList(), contacts_list)

    # Build up string of contacts
    return_string = ""
    for contact in contacts.list_of_people:
      return_string += "Name: " + contact.name + '\n'
      return_string += "    ID: " + str(contact.id) + '\n'
      return_string += "    Phone: " + contact.number.number + '\n'
    return_string += "Done listing.\n"
    # Return the string
    return return_string

  def addContact(self, new_person, filename):
    print "here"
    create_new_file = False

    contacts_binary = ""
    try:
      f = open(filename, "rb")
      contacts_binary = f.read()
      f.close()
    except IOError:
      print filename + ": File not found. Creating new file."
      create_new_file = True
    # Create empty ContactsList Thrift object.
    contacts = ContactsList()
    # Create an empty list inside that Thrift object.
    contacts.list_of_people = []
    # Load the contacts from address book file.
    contacts = self.deserialize(ContactsList(), contacts_binary)
    # Append the new person to the loaded contacts.
    contacts.list_of_people.append(new_person)
    # Serialize the contacts into Thrift binary so that it's ready to be written out to disk.
    serialized_contacts = self.serialize(contacts)

    return_message = "Done."
    if create_new_file == True:
      f = open(filename, "wb")
      f.write(serialized_contacts)
      f.close()
    else:
      try:
        f = open(filename, "wb")
        f.write(serialized_contacts)
        f.close()
      except IOError:
        return_message = filename + ": Error writing to file."
    return return_message

# Main program
handler = AddressbookHandler()
processor = AddressBook.Processor(handler)
transport = TSocket.TServerSocket(port=9090)
tfactory = TTransport.TBufferedTransportFactory()
pfactory = TBinaryProtocol.TBinaryProtocolFactory()

server = TServer.TSimpleServer(processor, transport, tfactory, pfactory)

# You could do one of these for a multithreaded server
#server = TServer.TThreadedServer(processor, transport, tfactory, pfactory)
#server = TServer.TThreadPoolServer(processor, transport, tfactory, pfactory)

print 'Starting the Address Book server...'
server.serve()
print 'Done.'
